{"meta":{"title":"Void","subtitle":null,"description":"爱吃爱玩的程序猿，热爱生活、热爱美食、热爱运动，有理想的一笔!","author":"Zhao Xiao Dan","url":"http://localhost:4000"},"pages":[{"title":"About","date":"2018-05-22T00:26:50.132Z","updated":"2018-05-20T12:02:05.372Z","comments":true,"path":"about/index.html","permalink":"http://localhost:4000/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-05-22T00:26:50.133Z","updated":"2018-05-20T12:02:05.372Z","comments":true,"path":"project/index.html","permalink":"http://localhost:4000/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-22T08:31:52.960Z","updated":"2018-05-20T12:02:05.372Z","comments":true,"path":"tags/index.html","permalink":"http://localhost:4000/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM内存模型","slug":"JVM内存模型","date":"2018-06-20T06:45:10.000Z","updated":"2018-06-20T06:45:49.211Z","comments":true,"path":"2018/06/20/JVM内存模型/","link":"","permalink":"http://localhost:4000/2018/06/20/JVM内存模型/","excerpt":"","text":"","categories":[],"tags":[{"name":"JVM内存模型","slug":"JVM内存模型","permalink":"http://localhost:4000/tags/JVM内存模型/"}]},{"title":"UML类图与类的关系详解","slug":"UML类图与类的关系详解","date":"2018-06-20T03:34:48.000Z","updated":"2018-06-20T03:36:47.018Z","comments":true,"path":"2018/06/20/UML类图与类的关系详解/","link":"","permalink":"http://localhost:4000/2018/06/20/UML类图与类的关系详解/","excerpt":"","text":"虚线箭头指向依赖； 实线箭头指向关联； 虚线三角指向接口； 实线三角指向父类； 空心菱形能分离而独立存在，是聚合； 实心菱形精密关联不可分，是组合； 上面是UML的语法。 在画类图的时候，理清类和类之间的关系是重点。类的关系有泛化(Generalization)、实现（Realization）、依赖(Dependency)和关联(Association)。其中关联又分为一般关联关系和聚合关系(Aggregation)，合成关系(Composition)。下面我们结合实例理解这些关系。 基本概念类图（Class Diagram）: 类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 类图的3个基本组件：类名、属性、方法。 泛化(generalization)：表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 实现（Realization）:在类图中就是接口和实现的关系。这个没什么好讲的。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 依赖(Dependency)：对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。后两种在后面分析。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 聚合(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。 组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。 多重性(Multiplicity) : 通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。如下图，一个割接通知可以关联0个到N个故障单。 聚合和组合的区别这两个比较难理解，重点说一下。聚合和组合的区别在于：聚合关系是“has-a”关系，组合关系是“contains-a”关系；聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除了聚合对象不一定就删除了代表部分事物的对象。组合中一旦删除了组合对象，同时也就删除了代表部分事物的对象。 实例分析联通客户响应OSS。系统有故障单、业务开通、资源核查、割接、业务重保、网络品质性能等功能模块。现在我们抽出部分需求做为例子讲解。 大家可以参照着类图，好好理解。 1． 通知分为一般通知、割接通知、重保通知。这个是继承关系。 2． NoticeService和实现类NoticeServiceImpl是实现关系。 3． NoticeServiceImpl通过save方法的参数引用Notice,是依赖关系。同时调用了BaseDao完成功能，也是依赖关系。 4． 割接通知和故障单之间通过中间类(通知电路)关联，是一般关联。 5． 重保通知和预案库间是聚合关系。因为预案库可以事先录入，和重保通知没有必然联系，可以独立存在。在系统中是手工从列表中选择。删除重保通知，不影响预案。 6． 割接通知和需求单之间是聚合关系。同理，需求单可以独立于割接通知存在。也就是说删除割接通知，不影响需求单。 7． 通知和回复是组合关系。因为回复不能独立于通知存在。也就是说删除通知，该条通知对应的回复也要级联删除。 经过以上的分析，相信大家对类的关系已经有比较好的理解了。大家有什么其它想法或好的见解，欢迎拍砖。 PS：还是那句话：以上类图用Enterprise Architect 7.5所画，在此推荐一下EA,非常不错。可以替代Visio和Rose了。Visio功能不够强大，Rose太重。唯有EA比较合适。 本文完全转载自http://www.uml.org.cn/oobject/201104212.asp","categories":[],"tags":[{"name":"类图","slug":"类图","permalink":"http://localhost:4000/tags/类图/"},{"name":"UML","slug":"UML","permalink":"http://localhost:4000/tags/UML/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2018-06-19T12:50:21.000Z","updated":"2018-06-20T01:48:56.001Z","comments":true,"path":"2018/06/19/设计模式-工厂模式/","link":"","permalink":"http://localhost:4000/2018/06/19/设计模式-工厂模式/","excerpt":"","text":"首先，简单工厂模式不属于23中涉及模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 一、简单工厂模式简单工厂模式模式分为三种： 1. 普通就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口：public interface Sender &#123; public void Send(); &#125; 其次，创建实现类：public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is mailsender!\"); &#125; &#125; public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is sms sender!\"); &#125; &#125; 最后，建工厂类：public class SendFactory &#123; public Sender produce(String type) &#123; if (\"mail\".equals(type)) &#123; return new MailSender(); &#125; else if (\"sms\".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println(\"请输入正确的类型!\"); return null; &#125; &#125; &#125; ``` 我们来测试下：``` javapublic class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce(\"sms\"); sender.Send(); &#125; &#125; 输出：this is sms sender! 2. 多个方法是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：将上面的代码做下修改，改动下SendFactory类就行，如下：public class SendFactory &#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下：public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125; &#125; 3. 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下：public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 二、工厂方法模式（Factory Method）简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 请看例子：接口public interface Sender &#123; public void Send(); &#125; 两个实现类public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is mailsender!\"); &#125; &#125; public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is sms sender!\"); &#125; &#125; 两个工厂类：public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125; &#125; public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125; &#125; 在提供一个接口：public interface Provider &#123; public Sender produce(); &#125; 测试类：public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125; &#125; 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 三、抽象工厂模式工厂方法模式和抽象工厂模式区别如下： 工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://localhost:4000/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://localhost:4000/tags/工厂模式/"}]},{"title":"GoLang","slug":"GoLang","date":"2018-06-19T09:51:02.000Z","updated":"2018-06-20T03:07:44.776Z","comments":true,"path":"2018/06/19/GoLang/","link":"","permalink":"http://localhost:4000/2018/06/19/GoLang/","excerpt":"","text":"一、下载安装下载对应操作系统的版本并安装，下载地址：http://www.golangtc.com/download， 譬如这里下载的是 go1.6beta1.windows-amd64.msi。 二、Windows下环境配置 GOROOT golang安装后的根目录，windows下默认为c:\\go\\，安装过程中会由安装程序自动写入系统环境变量中。 GOROOT: D:\\Program Files\\Go\\ GOBIN golang安装后根目录下的bin目录，即$GOROOT\\bin\\，windows平台下默认为c:\\go\\bin，安装过程中会由安装程序自动添加到PATH环境变量中。 GOBIN: %GOROOT%\\bin GOPATH golang的工作目录，是用来设置包加载路径的重要变量，也是go get和go install工具将会使用的目录。GOPATH变量可以同时制定多个目录，这些目录在Mac和Linux系统上通过:分隔，而在windows系统上通过;分隔。在大部分情况下都将是第一个路径优先。 GOPATH: D:\\golang\\workspace\\ 打开cmd，运行go version命令，如果看到下面信息说明环境变量配置成功。 C:\\Users\\Administrator&gt;go versiongo version go1.9.2 windows/amd64 三、LiteIDE安装 下载windows版本，下载地址：http://www.golangtc.com/download/liteide。 将liteidex28.windows-qt4.zip解压到本地即可，例如：c:\\liteide\\。 检查LiteIDE环境变量：工具栏选择切换当前环境win64,让后 查看 =&gt; 编辑当前环境 # native compiler windows amd64GOROOT=D:\\Program Files\\Go#GOBIN=GOARCH=amd64GOOS=windowsCGO_ENABLED=1PATH=D:\\golang\\mingw64\\bin;%GOROOT%\\bin;%PATH%LITEIDE_GDB=gdb64LITEIDE_MAKE=mingw32-makeLITEIDE_TERM=%COMSPEC%LITEIDE_TERMARGS=LITEIDE_EXEC=%COMSPEC%LITEIDE_EXECOPT=/C 四、MinGW-w64 GCC toolchains安装在LiteIDE上调试golang需要安装gdb，windows上则可使用MinGW-w64。LiteIDE的环境变量LITEIDE_GDB可以指定使用哪一个gdb来执行调试：在windows上，32位环境使用gdb.exe，64位环境使用gdb64.exe。在环境配置文件中可对这个环境变量进行手工配置。 下载MinGW GCC toolchains，下载地址：http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/rubenvb/gcc-4.8-release/ 将x86_64-w64-mingw32-gcc-4.8.0-win64_rubenvb.7z解压到本地即可，例如：D:\\golang\\mingw64\\。 检查修改LiteIDE环境变量：查看(V) =&gt; 编辑当前环境# native compiler windows amd64GOROOT=D:\\Program Files\\Go#GOBIN=GOARCH=amd64GOOS=windowsCGO_ENABLED=1PATH=D:\\golang\\mingw64\\bin;%GOROOT%\\bin;%PATH%LITEIDE_GDB=gdb64LITEIDE_MAKE=mingw32-makeLITEIDE_TERM=%COMSPEC%LITEIDE_TERMARGS=LITEIDE_EXEC=%COMSPEC%LITEIDE_EXECOPT=/C 五、GOPATH 设置查看 → 管理 GOPATH…，我们这里就使用安装 Go 时设置的那个 GOPATH 六、新建项目Ctrl + N 打开新项目或文件对话框，GOPATH 选择上一步的那个，模板选择 Go1 Command Project，最后取个名字，比如 test：点击 OK，test 项目已建立：完整测试代码：// test project main.gopackage mainimport ( \"fmt\")func main() &#123; var i int = 20 i += 30 j := i + 10 fmt.Println(j)&#125; 七、设置编译选项并编译编译 → 编译配置，BUILDARGS 设置为 -gcflags “-N -l”，以去掉编译优化，方便调试： 八、项目调试按 F5 启动调试，程序在 main 函数处停止：按 F10 （逐过程）进行单步调试，注意变量 i、j 值的变化：按 F11 （逐语句） 参考文章golang环境搭建Windows 平台下 LiteIDE 的安装和使用","categories":[],"tags":[{"name":"GoLang","slug":"GoLang","permalink":"http://localhost:4000/tags/GoLang/"},{"name":"环境配置","slug":"环境配置","permalink":"http://localhost:4000/tags/环境配置/"}]},{"title":"设计模式","slug":"设计模式","date":"2018-06-19T05:21:04.000Z","updated":"2018-06-19T09:51:15.977Z","comments":true,"path":"2018/06/19/设计模式/","link":"","permalink":"http://localhost:4000/2018/06/19/设计模式/","excerpt":"","text":"一 设计模式分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。 二 设计模式的六大原则总原则：开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 1. 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该吧类拆分。 2. 里氏替换原则（Liskov Subsitution Principle） 里氏替换原则（Liskov Subsitution Principle LSP）面向对象设计的基本原则之一。里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时。基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏替换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3. 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到的具体类时，不与具体类交互，而与具体类的上层接口交互。 4. 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5. 迪米特法则（最少知道原则）（Demeter Principle） 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6. 合成复用原则（Composite Reuse Principle） 原则是尽量首先使用合成/聚合的方式，而不是使用继承。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://localhost:4000/tags/设计模式/"}]},{"title":"Spring boot 系列（四）filter shiro","slug":"Spring boot 系列（四）","date":"2018-06-07T02:48:15.000Z","updated":"2018-06-19T02:48:33.679Z","comments":true,"path":"2018/06/07/Spring boot 系列（四）/","link":"","permalink":"http://localhost:4000/2018/06/07/Spring boot 系列（四）/","excerpt":"","text":"","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"filter","slug":"filter","permalink":"http://localhost:4000/tags/filter/"},{"name":"shiro","slug":"shiro","permalink":"http://localhost:4000/tags/shiro/"}]},{"title":"Spring boot 系列（三）tomcat部署","slug":"Spring boot 系列（三）","date":"2018-06-06T03:04:36.000Z","updated":"2018-06-19T02:48:06.402Z","comments":true,"path":"2018/06/06/Spring boot 系列（三）/","link":"","permalink":"http://localhost:4000/2018/06/06/Spring boot 系列（三）/","excerpt":"","text":"1. 修改打包方式 在pom.xml里设置 war 2. 移除嵌入式tomcat插件 在pom.xml里找到spring-boot-starter-web依赖节点，在其中添加如下代码 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 移除嵌入式tomcat插件 --&gt; &lt;!-- &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; --&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3. 添加servlet-api的依赖&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 4. 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法 /** * SprintBootApplication */@SpringBootApplicationpublic class BootApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; // 注意这里要指向原先用main方法执行的Application启动类 return application.sources(BootApplication.class); &#125; /** * @param args */ public static void main(String[] args) &#123; SpringApplication.run(BootApplication.class, args); &#125;&#125; 5. maven 打包 mvn clean compile package","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"tomcat部署","slug":"tomcat部署","permalink":"http://localhost:4000/tags/tomcat部署/"}]},{"title":"Spring boot 系列（二）文件上传","slug":"Spring boot 系列（二）","date":"2018-06-06T02:24:45.000Z","updated":"2018-06-19T02:48:19.909Z","comments":true,"path":"2018/06/06/Spring boot 系列（二）/","link":"","permalink":"http://localhost:4000/2018/06/06/Spring boot 系列（二）/","excerpt":"","text":"实现功能说明文件上传，并支持展示上传文件 问题描述 报错信息 org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.2737591724424319502.8080/work/Tomcat/localhost/ROOT] is not valid 报错代码 : file.transferTo 方法 public String storeScale(MultipartFile file, String basePath, int maxWidth) throws Exception &#123; validateFile(file); String root = getRoot(); String path = FileNameUtils.genPathAndFileName(getExt(file.getOriginalFilename())); File temp = new File(root + appContext.getTempDir() + path); checkDirAndCreate(temp); try &#123; file.transferTo(temp); // 根据临时文件生成略缩图 String dest = root + basePath + path; ImageUtils.scaleImageByWidth(temp.getAbsolutePath(), dest, maxWidth); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; temp.delete(); &#125; return basePath + path;&#125; 问题分析 上面源码文件使用路径 ，相对路径, 预期路径应该是 root + appContext.getTempDir() + path ，但是报错却是一个系统临时文件路径 （Tomcat的） 其次，由于transferTo方法报错，应该是写文件的时候报错，跟踪源码如下 /** * Spring MultipartHttpServletRequest adapter, wrapping a Servlet 3.0 HttpServletRequest * and its Part objects. Parameters get exposed through the native request's getParameter * methods - without any custom processing on our side. * * @author Juergen Hoeller * @author Rossen Stoyanchev * @since 3.1 */public class StandardMultipartHttpServletRequest extends AbstractMultipartHttpServletRequest &#123; ... @Override public void transferTo(File dest) throws IOException, IllegalStateException &#123; this.part.write(dest.getPath()); // 写文件方法入口 if (dest.isAbsolute() &amp;&amp; !dest.exists()) &#123; // Servlet 3.0 Part.write is not guaranteed to support absolute file paths: // may translate the given path to a relative location within a temp dir // (e.g. on Jetty whereas Tomcat and Undertow detect absolute paths). // At least we offloaded the file from memory storage; it'll get deleted // from the temp dir eventually in any case. And for our user's purposes, // we can manually copy it to the requested location as a fallback. FileCopyUtils.copy(this.part.getInputStream(), new FileOutputStream(dest)); &#125; &#125; ...&#125;/** * Adaptor to allow &#123;@link FileItem&#125; objects generated by the package renamed * commons-upload to be used by the Servlet 3.0 upload API that expects * &#123;@link Part&#125;s. */public class ApplicationPart implements Part &#123; ... @Override public void write(String fileName) throws IOException &#123; File file = new File(fileName); if (!file.isAbsolute()) &#123; // 此处判断如果不是绝对路径，则会添加location file = new File(location, fileName); &#125; try &#123; fileItem.write(file); &#125; catch (Exception e) &#123; throw new IOException(e); &#125; &#125; ...&#125; 源码一目了然，使用Servlet3.0的支持的上传文件功能时，如果我们没有使用绝对路径的话，transferTo方法会在相对路径前添加一个location路径，即：file = new File(location, fileName);。当然，这也影响了SpringMVC的Multipartfile的使用 解决方法 使用绝对路径 指定临时文件location路径 /** * 文件上传临时路径 */ @Bean MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); String location = appContext.getRoot(); File file = new File(location); if (!file.exists()) &#123; file.mkdirs();&#125; factory.setLocation(location); return factory.createMultipartConfig(); &#125; /** * appContext.getRoot() 文件存放路径 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/store/**\").addResourceLocations(\"file:\" + appContext.getRoot() + \"/store/\"); super.addResourceHandlers(registry); &#125; 文章参考：https://blog.csdn.net/daniel7443/article/details/51620308","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"文件上传","slug":"文件上传","permalink":"http://localhost:4000/tags/文件上传/"}]},{"title":"org.apache.maven.archiver.MavenArchiver.getManifest错误","slug":"eclipse-maven","date":"2018-05-30T03:36:53.000Z","updated":"2018-05-30T03:45:14.979Z","comments":true,"path":"2018/05/30/eclipse-maven/","link":"","permalink":"http://localhost:4000/2018/05/30/eclipse-maven/","excerpt":"","text":"在给eclipse换了高版本的maven插件后，引入jar包报如下的错误：org.apache.maven.archiver.MavenArchiver.getManifest(org.apache.maven.project 解决方法是：help–&gt;install new software, 然后add，添加如下链接， http://repo1.maven.org/maven2/.m2e/connectors/m2eclipse-mavenarchiver/0.17.2/N/LATEST/ 一直下一步就可以，后面提示重启eclipse，然后重启eclipse后，右击项目，点击maven–&gt;update project， 错误就没了","categories":[],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://localhost:4000/tags/eclipse/"},{"name":"maven","slug":"maven","permalink":"http://localhost:4000/tags/maven/"}]},{"title":"Spring boot 系列（一）相关文档","slug":"Spring boot 系列（一）","date":"2018-05-30T03:17:11.000Z","updated":"2018-06-19T02:48:15.681Z","comments":true,"path":"2018/05/30/Spring boot 系列（一）/","link":"","permalink":"http://localhost:4000/2018/05/30/Spring boot 系列（一）/","excerpt":"","text":"Spring官方网站本身使用Spring框架开发，随着功能以及业务逻辑的日益复杂，应用伴随着大量的XML配置文件以及复杂的Bean依赖关系。随着Spring 3.0的发布，Spring IO团队逐渐开始摆脱XML配置文件，并且在开发过程中大量使用“约定优先配置”（convention over configuration）的思想来摆脱Spring框架中各类繁复纷杂的配置（即时是Java Config）。 Spring Boot正是在这样的一个背景下被抽象出来的开发框架，它本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box），大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 相关文档 Spring 中文文档 http://spring.cndocs.ml/ Spring boot 中文文档 http://blog.geekidentity.com/spring/spring_boot_translation/ spring boot 2.0 官方文档 https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/ Spring Boot教程 https://www.yiibai.com/spring-boot/ spring boot 实践学习案例 https://github.com/JeffLi1993/springboot-learning-example","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"}]},{"title":"微信公共账号（一）","slug":"微信公共账号（一）","date":"2018-05-26T01:50:04.000Z","updated":"2018-06-04T00:51:37.373Z","comments":true,"path":"2018/05/26/微信公共账号（一）/","link":"","permalink":"http://localhost:4000/2018/05/26/微信公共账号（一）/","excerpt":"","text":"订目标，做计划，大量的行动。——陈安之言之易，行之难。——吕不韦 相关文档、工具 微信公众平台技术文档官网 微信Java开发工具包 weixin-java-tools weixin-java-tools Demo 微信服务号本地调试,参考外网访问你机器上的Demo 问题AES加密时的 java.security.InvalidKeyException: Illegal key size 异常程序代码// 设置加密模式为AES的CBC模式Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");SecretKeySpec keySpec = new SecretKeySpec(aesKey, \"AES\");IvParameterSpec iv = new IvParameterSpec(aesKey, 0, 16);cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);// 加密byte[] encrypted = cipher.doFinal(unencrypted);... 当执行到cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv); 时, 如果密钥大于128, 会抛出java.security.InvalidKeyException: Illegal key size 异常.因为密钥长度是受限制的, java运行时环境读到的是受限的policy文件. 文件位于${java_home}/jre/lib/security, 这种限制是因为美国对软件出口的控制. 处理办法: 在官方网站下载JCE无限制权限策略文件 JDK6的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.htmlJDK7的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.htmlJDK8的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt如果安装了JRE，将两个jar文件放到%JRE_HOME%\\lib\\security目录下覆盖原来的文件如果安装了JDK，还要将两个jar文件也放到%JDK_HOME%\\jre\\lib\\security目录下覆盖原来文件 更多问题参考weixin-java-tools微信Java SDK开发文档","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"maven","slug":"maven","permalink":"http://localhost:4000/tags/maven/"},{"name":"微信公共号","slug":"微信公共号","permalink":"http://localhost:4000/tags/微信公共号/"},{"name":"java","slug":"java","permalink":"http://localhost:4000/tags/java/"}]},{"title":"外网访问你机器上的Demo","slug":"外网访问你机器上的Demo","date":"2018-05-25T03:10:11.000Z","updated":"2018-05-25T03:22:00.630Z","comments":true,"path":"2018/05/25/外网访问你机器上的Demo/","link":"","permalink":"http://localhost:4000/2018/05/25/外网访问你机器上的Demo/","excerpt":"","text":"想在外网访问你机器上的demo? 几个内网端口映射服务网站 http://wendal.cn Nutz社区提供的ngrok服务，详细访问 https://nutz.cn/yvr/t/33b68q9106imspallbj4c6aa0p http://www.mofasuidao.cn/ 拥有魔法隧道，让你穿越世界，引领「内网穿透」潮流，为世界带来美好的改变 http://natapp.cn/ http://ngrok.io == http://ngrok.com http://ngrok.2bdata.com/ http://www.ngrok.cc/ http://www.nat123.com/ ngrok使用 下载ngrok,点我 打开shell或cmd，进入ngrok目录，运行 ngrok -config ngrok.cfg -subdomain my-domain 8080 如果运行失败，请更换my-domain为其它字符串，直至连接成功； 外网访问地址：http://my-domain.tunnel.qydev.com/ （注意my-domain要跟上面的一致）；","categories":[],"tags":[{"name":"代理","slug":"代理","permalink":"http://localhost:4000/tags/代理/"}]},{"title":"计划","slug":"计划","date":"2018-05-25T01:51:48.000Z","updated":"2018-05-25T09:05:34.208Z","comments":true,"path":"2018/05/25/计划/","link":"","permalink":"http://localhost:4000/2018/05/25/计划/","excerpt":"","text":"西汉·戴圣《礼记·中庸》：“凡事豫则立，不豫则废。” 计划 个人博客 微信服务号石门蓝小球 PC站Mvp51 个人博客 Hexo博客搭建教程 Hexo手机端样式调整 Hexo支持评论功能，目前计划评论功能不使用第三方插件 石门蓝小球 微信服务号后台，支持用户上传收集信息（文字、图片、语音） 支持查询石家庄附件球场，通过关键词+Hexo静态页面 Mvp51 设计图效果 附近球场、球友、球队功能支持","categories":[],"tags":[{"name":"计划","slug":"计划","permalink":"http://localhost:4000/tags/计划/"}]},{"title":"Hexo工作原理","slug":"Hexo如何工作","date":"2018-05-24T01:18:22.000Z","updated":"2018-05-24T01:27:54.140Z","comments":true,"path":"2018/05/24/Hexo如何工作/","link":"","permalink":"http://localhost:4000/2018/05/24/Hexo如何工作/","excerpt":"","text":"你可能用过hexo(或者jekyll)来搭建自己的博客网站。通常我们在安装、配置完成hexo之后，借助hexo，一般通过以下步骤，就可以完成一篇博客的编写及发布，真是方便极了： |$ hexo init // 创建一个新的hexo项目$ hexo new mynewblog // 新建一篇标题为mynewblog的文章$ hexo server // 为hexo在本地起一个http server, 然后通过浏览器访问博客$ hexo generate // 生成将要发布的博客网站包含html在内的静态资源$ hexo deploy // 将generate的结果发布到_config.yml中指定的仓库 | 可是，从hexo init到hexo deploy中间发生了什么呢？为了搞清楚这一过程、理解hexo的工作原理，本文将试着回答以下问题: 命令行中的hexo是什么 hexo是怎么将我们写好的markdown转换成html的 hexo插件是如何工作的 本地的hexo项目和git page有什么关系 本文不是: hexo的安装、使用教程 git page的使用教程 命令行中的hexo是什么?hexo项目在github上已经有超过17k的star了，但是你知道吗，日常我们在命令行”操作”hexo时所输入的hexo(例如hexo init)并不是这个17k个star的项目! 是的，我们在命令行中所输入的”hexo”实际是hexo-cli项目，该项目在github上的star还不足50个。 hexo可以粗略分为三个子项目，分别是: hexo-cli hexo (下文中用hexo core来指代) hexo plugins 其中hexo plugins不是指某一个单独的项目，而是泛指所有的hexo plugin项目。 请看下图:让我们结合这张图来大致看看这三个项目的作用(下面的链接均是指向Github中相关的源码): hexo-cli: hexo命令行项目，作用是: 启动hexo命令(进程)，及其参数解析机制。每次我们输入’hexo xxx’命令后，都会通过node调用hexo-cli中的entry函数(比如，可以把’hexo init’视为’node hexo-cli/entry.js init’) 实现hexo命令的三个初始参数(功能): init / version / help 加载hexo核心模块，并初始化 hexo core: hexo核心，他的主要作用如下: 实现了hexo功能扩展对象 实现了hexo核心功能, 如new, publish, generate等（其实是一些hexo插件，下文中会详细分析） hexo plugins: 指一些能够扩展hexo的插件。插件可以按功能分成两类: 扩展hexo命令的参数，如hexo-server(安装这个插件以后才能使用hexo server命令) 扩展hexo解析文件的”能力”，如增加jade模版解析功能的hexo-render-jade插件 从markdown到html的旅程简单来说，hexo中，从markdown到html的generate过程中做了两件事： 模板渲染 模板渲染 是的，就是这样，就是两次模板渲染。只不过两次渲染的输入、渲染模板的引擎、输出不一样。此处应该有一个表格：还得有一张图: 对上面表格和图的说明: hexo core在generate的过程中会产生一个对象，我们在这里把这个对象称为article。第一次渲染的主要目的就是给这个对象添加title,content等属性。其中: article.title, article.date, article.tags, article.categories等属性来自yml front的部分 article.content是markdown文章解析后的html片段 hexo项目目录下包含三个子目录， source目录，写博客的主要工作目录。这个目录下存放的是我们的markdown文章以及js, images, css themes目录，主题目录，定义了即将生成的html的layout, 和html中需要加载的css, js, images public目录, hexo generate的最终输出目录。里面包含了整个博客网站的html, css, js, images 第二次渲染，需要引入对应模板文件格式的插件，如.ejs文件就需要使用hexo-render-ejs插件，.jade文件需要使用hexo-render-jade插件，而.sass文件则需要hexo-render-sass插件来转换成css文件。hexo的这一设计有点类似webpack中的loader。 hexo插件是如何工作的hexo和webpack还有一点类似的地方就是插件驱动理念。即hexo(和webpack)是先实现一套(插件)扩展系统，然后再往扩展系统中添加插件来实现自身的功能。即我们日常使用的hexo init, hexo new，hexo generate等等功能都是通过一个个插件(其实就是一个个function)实现的。 具体来讲就是: hexo.extend这个对象的每个属性都是一个用来绑定(特定)插件的对象。（所谓”绑定”，其实就是对象的register方法） hexo初始化过程中先加载内部插件，再加载外部插件 而这些插件的功能分为两大类: 命令行插件和generate过程相关功能，例如： 命令行插件, hexo new, 是在hexo.extend.console对象上绑定的一个插件 generate过程相关的插件，如上文提到的往article对象添加title,content等属性的功能，是通过往hexo.extend.processer对象上绑定post插件来实现的 所以，当我们想自己动手写插件时，就是像hexo官网给出的这样,调用某个对象的register方法，如hexo.extend.console.register。 hexo和git page 如上图，(用户通过浏览器访问到的)git page上的博客网站其实是hexo generate之后生成的public目录下的内容。 所以，一个hexo博客项目应该有两个仓库: (基于hexo init结果的)博客编写仓库。可以把这个项目看成一个代码库，用来”开发”博客网站(包含写博客，生成博客等任务) 存放(hexo generate结果的)public目录仓库。这个项目是”只读”的，我们不会直接修改这个仓库的内容，我们也不会对这个仓库直接进行git pull、git commit、git push等常规操作。这个仓库的内容就是public目下的内容，即是通过hexo generate产生、hexo deploy提交的。 总结hexo简洁、强大的功能来自于自身优雅的系统设计: hexo进程启动、hexo核心对象封装、插件系统分别独立 自身采用插件驱动，生来就具备高可扩展性 文章转载于hexo是怎么工作的","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://localhost:4000/tags/Hexo/"}]},{"title":"Windows Git安装环境配置","slug":"Windows Git安装环境配置","date":"2018-05-23T08:10:42.000Z","updated":"2018-05-25T02:01:21.329Z","comments":true,"path":"2018/05/23/Windows Git安装环境配置/","link":"","permalink":"http://localhost:4000/2018/05/23/Windows Git安装环境配置/","excerpt":"","text":"世上无难事只怕有心人！ 下载安装 从Git官网下载Windows安装包，官网地址 点我 参考https://blog.csdn.net/dietime1943/article/details/71751007安装 环境变量配置环境变量Path 或者 直接使用 git-bash.exeD:\\Program Files\\Git\\cmd Git常用命令简单命令# 版本查看$ git --versiongit version 2.17.0.windows.1 新建代码库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置# 显示当前Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2]# 停止追踪指定文件，但该文件会保留在工作区$ git rm -cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，代替上一次提交# 如果代码没有任何变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit, 并包括指定文件的新变化$ git commit --amend [file1] [file2] 分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]$ 删除远程分支$ git push origin -delete [branch-name]$ git branch -dr [remote/branch] Git原理Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 相关链接阮一峰常用 Git 命令清单","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"http://localhost:4000/tags/windows/"},{"name":"git","slug":"git","permalink":"http://localhost:4000/tags/git/"}]},{"title":"Hexo搭建博客","slug":"Hexo搭建博客","date":"2018-05-23T01:37:40.000Z","updated":"2018-05-24T01:21:52.084Z","comments":true,"path":"2018/05/23/Hexo搭建博客/","link":"","permalink":"http://localhost:4000/2018/05/23/Hexo搭建博客/","excerpt":"","text":"零基础搭建个人博客（Hexo + Git）","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://localhost:4000/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-22T07:29:40.327Z","updated":"2018-05-24T01:57:38.791Z","comments":true,"path":"2018/05/22/hello-world/","link":"","permalink":"http://localhost:4000/2018/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://localhost:4000/tags/Hexo/"}]}]}