{"meta":{"title":"Void","subtitle":null,"description":"爱吃爱玩的程序猿，热爱生活、热爱美食、热爱运动，有理想的一笔!","author":"Zhao Xiao Dan","url":"http://localhost:4000"},"pages":[{"title":"Project","date":"2018-05-22T00:26:50.133Z","updated":"2018-05-20T12:02:05.372Z","comments":true,"path":"project/index.html","permalink":"http://localhost:4000/project/index.html","excerpt":"","text":""},{"title":"About","date":"2018-05-22T00:26:50.132Z","updated":"2018-05-20T12:02:05.372Z","comments":true,"path":"about/index.html","permalink":"http://localhost:4000/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-22T08:31:52.960Z","updated":"2018-05-20T12:02:05.372Z","comments":true,"path":"tags/index.html","permalink":"http://localhost:4000/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM类加载机制","slug":"JVM类加载机制","date":"2018-06-22T06:02:56.000Z","updated":"2018-06-22T06:06:03.332Z","comments":true,"path":"2018/06/22/JVM类加载机制/","link":"","permalink":"http://localhost:4000/2018/06/22/JVM类加载机制/","excerpt":"","text":"原文出处： ziwenxie 如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。 加载加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。 验证这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： public static int v = 8080; 实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器方法之中，这里我们后面会解释。但是注意如果声明为： public static final int v = 8080; 在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的： CONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info 等类型的常量。 下面我们解释一下符号引用和直接引用的概念： 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。 初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证方法执行之前，父类的方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。 注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取Class对象，不会触发类的初始化。 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。 类加载器虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器： 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。 JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。 采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。 在有些情境中可能会出现要我们自己来实现一个类加载器的需求，由于这里涉及的内容比较广泛，我想以后单独写一篇文章来讲述，不过这里我们还是稍微来看一下。我们直接看一下jdk中的ClassLoader的源码实现：protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClass0(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c;&#125; 首先通过Class c = findLoadedClass(name);判断一个类是否已经被加载过。 如果没有被加载过执行if (c == null)中的程序，遵循双亲委派的模型，首先会通过递归从父加载器开始找，直到父类加载器是Bootstrap ClassLoader为止。 最后根据resolve的值，判断这个class是否需要解析。 而上面的findClass()的实现如下，直接抛出一个异常，并且方法是protected，很明显这是留给我们开发者自己去实现的，这里我们以后我们单独写一篇文章来讲一下如何重写findClass方法来实现我们自己的类加载器。 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } ReferencesUNDERSTANDING THE JVM","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://localhost:4000/tags/JVM/"},{"name":"类加载机制","slug":"类加载机制","permalink":"http://localhost:4000/tags/类加载机制/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2018-06-21T10:06:39.000Z","updated":"2018-06-22T06:25:13.460Z","comments":true,"path":"2018/06/21/设计模式-单例模式/","link":"","permalink":"http://localhost:4000/2018/06/21/设计模式-单例模式/","excerpt":"","text":"单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。 一、特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 二、懒汉模式懒汉式单例模式：在类加载时不初始化。 1. 懒汉，线程不安全public class SingletonDemo1 &#123; private static SingletonDemo1 instance; private SingletonDemo1()&#123;&#125; public static SingletonDemo1 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo1(); &#125; return instance; &#125;&#125; 这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。 2. 懒汉，线程安全public class SingletonDemo2 &#123; private static SingletonDemo2 instance; private SingletonDemo2()&#123;&#125; public static synchronized SingletonDemo2 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo2(); &#125; return instance; &#125;&#125; 这种写法在getInstance()方法中加入了synchronized锁。能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是效率很低（因为锁），并且大多数情况下不需要同步。 3. 双重校验锁public class SingletonDemo7 &#123; private volatile static SingletonDemo7 singletonDemo7; private SingletonDemo7()&#123;&#125; public static SingletonDemo7 getSingletonDemo7()&#123; if (singletonDemo7 == null) &#123; synchronized (SingletonDemo7.class) &#123; if (singletonDemo7 == null) &#123; singletonDemo7 = new SingletonDemo7(); &#125; &#125; &#125; return singletonDemo7; &#125;&#125; 二、饿汉模式在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。 1. 饿汉public class SingletonDemo3 &#123; private static SingletonDemo3 instance = new SingletonDemo3(); private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return instance; &#125;&#125; 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，这时候初始化instance显然没有达到lazy loading的效果。 2. 饿汉，变种public class SingletonDemo4 &#123; private static SingletonDemo4 instance = null; static&#123; instance = new SingletonDemo4(); &#125; private SingletonDemo4()&#123;&#125; public static SingletonDemo4 getInstance()&#123; return instance; &#125;&#125; 表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance 3. 静态内部类public class SingletonDemo5 &#123; private static class SingletonHolder&#123; private static final SingletonDemo5 instance = new SingletonDemo5(); &#125; private SingletonDemo5()&#123;&#125; public static final SingletonDemo5 getInsatance()&#123; return SingletonHolder.instance; &#125;&#125; 这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第1种和第2种方式不同的是（很细微的差别）：第1种和第2种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方法就显得更合理。 三、枚举public enum SingletonDemo6 &#123; instance; public void whateverMethod()&#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://localhost:4000/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"http://localhost:4000/tags/单例模式/"}]},{"title":"JVM内存模型","slug":"JVM内存模型","date":"2018-06-20T06:45:10.000Z","updated":"2018-06-20T11:50:33.142Z","comments":true,"path":"2018/06/20/JVM内存模型/","link":"","permalink":"http://localhost:4000/2018/06/20/JVM内存模型/","excerpt":"","text":"","categories":[],"tags":[{"name":"JVM内存模型","slug":"JVM内存模型","permalink":"http://localhost:4000/tags/JVM内存模型/"}]},{"title":"UML类图与类的关系详解","slug":"UML类图与类的关系详解","date":"2018-06-20T03:34:48.000Z","updated":"2018-06-20T03:36:47.018Z","comments":true,"path":"2018/06/20/UML类图与类的关系详解/","link":"","permalink":"http://localhost:4000/2018/06/20/UML类图与类的关系详解/","excerpt":"","text":"虚线箭头指向依赖； 实线箭头指向关联； 虚线三角指向接口； 实线三角指向父类； 空心菱形能分离而独立存在，是聚合； 实心菱形精密关联不可分，是组合； 上面是UML的语法。 在画类图的时候，理清类和类之间的关系是重点。类的关系有泛化(Generalization)、实现（Realization）、依赖(Dependency)和关联(Association)。其中关联又分为一般关联关系和聚合关系(Aggregation)，合成关系(Composition)。下面我们结合实例理解这些关系。 基本概念类图（Class Diagram）: 类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 类图的3个基本组件：类名、属性、方法。 泛化(generalization)：表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 实现（Realization）:在类图中就是接口和实现的关系。这个没什么好讲的。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 依赖(Dependency)：对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。后两种在后面分析。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 聚合(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。 组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。 多重性(Multiplicity) : 通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。如下图，一个割接通知可以关联0个到N个故障单。 聚合和组合的区别这两个比较难理解，重点说一下。聚合和组合的区别在于：聚合关系是“has-a”关系，组合关系是“contains-a”关系；聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除了聚合对象不一定就删除了代表部分事物的对象。组合中一旦删除了组合对象，同时也就删除了代表部分事物的对象。 实例分析联通客户响应OSS。系统有故障单、业务开通、资源核查、割接、业务重保、网络品质性能等功能模块。现在我们抽出部分需求做为例子讲解。 大家可以参照着类图，好好理解。 1． 通知分为一般通知、割接通知、重保通知。这个是继承关系。 2． NoticeService和实现类NoticeServiceImpl是实现关系。 3． NoticeServiceImpl通过save方法的参数引用Notice,是依赖关系。同时调用了BaseDao完成功能，也是依赖关系。 4． 割接通知和故障单之间通过中间类(通知电路)关联，是一般关联。 5． 重保通知和预案库间是聚合关系。因为预案库可以事先录入，和重保通知没有必然联系，可以独立存在。在系统中是手工从列表中选择。删除重保通知，不影响预案。 6． 割接通知和需求单之间是聚合关系。同理，需求单可以独立于割接通知存在。也就是说删除割接通知，不影响需求单。 7． 通知和回复是组合关系。因为回复不能独立于通知存在。也就是说删除通知，该条通知对应的回复也要级联删除。 经过以上的分析，相信大家对类的关系已经有比较好的理解了。大家有什么其它想法或好的见解，欢迎拍砖。 PS：还是那句话：以上类图用Enterprise Architect 7.5所画，在此推荐一下EA,非常不错。可以替代Visio和Rose了。Visio功能不够强大，Rose太重。唯有EA比较合适。 本文完全转载自http://www.uml.org.cn/oobject/201104212.asp","categories":[],"tags":[{"name":"类图","slug":"类图","permalink":"http://localhost:4000/tags/类图/"},{"name":"UML","slug":"UML","permalink":"http://localhost:4000/tags/UML/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2018-06-19T12:50:21.000Z","updated":"2018-06-21T03:15:58.062Z","comments":true,"path":"2018/06/19/设计模式-工厂模式/","link":"","permalink":"http://localhost:4000/2018/06/19/设计模式-工厂模式/","excerpt":"","text":"首先，简单工厂模式不属于23中涉及模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 一、简单工厂模式简单工厂模式模式分为三种： 1. 普通就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口：public interface Sender &#123; public void Send(); &#125; 其次，创建实现类：public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is mailsender!\"); &#125; &#125; public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is sms sender!\"); &#125; &#125; 最后，建工厂类：public class SendFactory &#123; public Sender produce(String type) &#123; if (\"mail\".equals(type)) &#123; return new MailSender(); &#125; else if (\"sms\".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println(\"请输入正确的类型!\"); return null; &#125; &#125; &#125; ``` 我们来测试下：``` javapublic class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce(\"sms\"); sender.Send(); &#125; &#125; 输出：this is sms sender! 2. 多个方法是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：将上面的代码做下修改，改动下SendFactory类就行，如下：public class SendFactory &#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下：public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125; &#125; 3. 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下：public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 二、工厂方法模式（Factory Method）简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 请看例子：接口public interface Sender &#123; public void Send(); &#125; 两个实现类public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is mailsender!\"); &#125; &#125; public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is sms sender!\"); &#125; &#125; 两个工厂类：public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125; &#125; public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125; &#125; 在提供一个接口：public interface Provider &#123; public Sender produce(); &#125; 测试类：public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125; &#125; 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 三、抽象工厂模式工厂方法模式和抽象工厂模式区别如下： 工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。/抽象产品（Bmw和Audi同理） abstract class BenzCar&#123; private String name; public abstract void drive(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; //具体产品（Bmw和Audi同理） class BenzSportCar extends BenzCar&#123; public void drive()&#123; System.out.println(this.getName()+\"----BenzSportCar-----------------------\"); &#125; &#125; class BenzBusinessCar extends BenzCar&#123; public void drive()&#123; System.out.println(this.getName()+\"----BenzBusinessCar-----------------------\"); &#125; &#125; abstract class BmwCar&#123; private String name; public abstract void drive(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; class BmwSportCar extends BmwCar&#123; public void drive()&#123; System.out.println(this.getName()+\"----BmwSportCar-----------------------\"); &#125; &#125; class BmwBusinessCar extends BmwCar&#123; public void drive()&#123; System.out.println(this.getName()+\"----BmwBusinessCar-----------------------\"); &#125; &#125; abstract class AudiCar&#123; private String name; public abstract void drive(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; class AudiSportCar extends AudiCar&#123; public void drive()&#123; System.out.println(this.getName()+\"----AudiSportCar-----------------------\"); &#125; &#125; class AudiBusinessCar extends AudiCar&#123; public void drive()&#123; System.out.println(this.getName()+\"----AudiBusinessCar-----------------------\"); &#125; &#125; //抽象工厂 abstract class Driver3&#123; public abstract BenzCar createBenzCar(String car) throws Exception; public abstract BmwCar createBmwCar(String car) throws Exception; public abstract AudiCar createAudiCar(String car) throws Exception; &#125; //具体工厂 class SportDriver extends Driver3&#123; public BenzCar createBenzCar(String car) throws Exception &#123; return new BenzSportCar(); &#125; public BmwCar createBmwCar(String car) throws Exception &#123; return new BmwSportCar(); &#125; public AudiCar createAudiCar(String car) throws Exception &#123; return new AudiSportCar(); &#125; &#125; class BusinessDriver extends Driver3&#123; public BenzCar createBenzCar(String car) throws Exception &#123; return new BenzBusinessCar(); &#125; public BmwCar createBmwCar(String car) throws Exception &#123; return new BmwBusinessCar(); &#125; public AudiCar createAudiCar(String car) throws Exception &#123; return new AudiBusinessCar(); &#125; &#125; //老板 public class BossAbstractFactory &#123; public static void main(String[] args) throws Exception &#123; Driver3 d = new BusinessDriver(); AudiCar car = d.createAudiCar(\"\"); car.drive(); &#125; &#125; 所以抽象工厂模式一般用于具有产品树和产品族的场景下。抽象工厂模式的缺点：如果需要增加新的产品树，那么就要新增三个产品类，比如VolvoCar，VolvoSportCar,VolvoSportCar，并且要修改三个工厂类。这样大批量的改动是很丑陋的做法。所以可以用简单工厂配合反射来改进抽象工厂：UML图略。 abstract class BenzCar{ private String name; public abstract void drive(); public String getName() { return name; } public void setName(String name) { this.name = name; } } class BenzSportCar extends BenzCar{ public void drive(){ System.out.println(this.getName()+\"----BenzSportCar-----------------------\"); } } class BenzBusinessCar extends BenzCar{ public void drive(){ System.out.println(this.getName()+\"----BenzBusinessCar-----------------------\"); } } abstract class BmwCar{ private String name; public abstract void drive(); public String getName() { return name; } public void setName(String name) { this.name = name; } } class BmwSportCar extends BmwCar{ public void drive(){ System.out.println(this.getName()+\"----BmwSportCar-----------------------\"); } } class BmwBusinessCar extends BmwCar{ public void drive(){ System.out.println(this.getName()+\"----BmwBusinessCar-----------------------\"); } } abstract class AudiCar{ private String name; public abstract void drive(); public String getName() { return name; } public void setName(String name) { this.name = name; } } class AudiSportCar extends AudiCar{ public void drive(){ System.out.println(this.getName()+\"----AudiSportCar-----------------------\"); } } class AudiBusinessCar extends AudiCar{ public void drive(){ System.out.println(this.getName()+\"----AudiBusinessCar-----------------------\"); } } /** * 简单工厂通过反射改进抽象工厂及其子工厂 * @author Administrator * */ class Driver3{ public static BenzCar createBenzCar(String car) throws Exception { return (BenzCar) Class.forName(car).newInstance(); } public static BmwCar createBmwCar(String car) throws Exception { return (BmwCar) Class.forName(car).newInstance(); } public static AudiCar createAudiCar(String car) throws Exception { return (AudiCar) Class.forName(car).newInstance(); } } //客户端 public class SimpleAndAbstractFactory { public static void main(String[] args) throws Exception { AudiCar car = Driver3.createAudiCar(\"com.java.pattendesign.factory.AudiSportCar\"); car.drive(); } }","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://localhost:4000/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://localhost:4000/tags/工厂模式/"}]},{"title":"GoLang","slug":"GoLang","date":"2018-06-19T09:51:02.000Z","updated":"2018-06-20T03:07:44.776Z","comments":true,"path":"2018/06/19/GoLang/","link":"","permalink":"http://localhost:4000/2018/06/19/GoLang/","excerpt":"","text":"一、下载安装下载对应操作系统的版本并安装，下载地址：http://www.golangtc.com/download， 譬如这里下载的是 go1.6beta1.windows-amd64.msi。 二、Windows下环境配置 GOROOT golang安装后的根目录，windows下默认为c:\\go\\，安装过程中会由安装程序自动写入系统环境变量中。 GOROOT: D:\\Program Files\\Go\\ GOBIN golang安装后根目录下的bin目录，即$GOROOT\\bin\\，windows平台下默认为c:\\go\\bin，安装过程中会由安装程序自动添加到PATH环境变量中。 GOBIN: %GOROOT%\\bin GOPATH golang的工作目录，是用来设置包加载路径的重要变量，也是go get和go install工具将会使用的目录。GOPATH变量可以同时制定多个目录，这些目录在Mac和Linux系统上通过:分隔，而在windows系统上通过;分隔。在大部分情况下都将是第一个路径优先。 GOPATH: D:\\golang\\workspace\\ 打开cmd，运行go version命令，如果看到下面信息说明环境变量配置成功。 C:\\Users\\Administrator&gt;go versiongo version go1.9.2 windows/amd64 三、LiteIDE安装 下载windows版本，下载地址：http://www.golangtc.com/download/liteide。 将liteidex28.windows-qt4.zip解压到本地即可，例如：c:\\liteide\\。 检查LiteIDE环境变量：工具栏选择切换当前环境win64,让后 查看 =&gt; 编辑当前环境 # native compiler windows amd64GOROOT=D:\\Program Files\\Go#GOBIN=GOARCH=amd64GOOS=windowsCGO_ENABLED=1PATH=D:\\golang\\mingw64\\bin;%GOROOT%\\bin;%PATH%LITEIDE_GDB=gdb64LITEIDE_MAKE=mingw32-makeLITEIDE_TERM=%COMSPEC%LITEIDE_TERMARGS=LITEIDE_EXEC=%COMSPEC%LITEIDE_EXECOPT=/C 四、MinGW-w64 GCC toolchains安装在LiteIDE上调试golang需要安装gdb，windows上则可使用MinGW-w64。LiteIDE的环境变量LITEIDE_GDB可以指定使用哪一个gdb来执行调试：在windows上，32位环境使用gdb.exe，64位环境使用gdb64.exe。在环境配置文件中可对这个环境变量进行手工配置。 下载MinGW GCC toolchains，下载地址：http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/rubenvb/gcc-4.8-release/ 将x86_64-w64-mingw32-gcc-4.8.0-win64_rubenvb.7z解压到本地即可，例如：D:\\golang\\mingw64\\。 检查修改LiteIDE环境变量：查看(V) =&gt; 编辑当前环境# native compiler windows amd64GOROOT=D:\\Program Files\\Go#GOBIN=GOARCH=amd64GOOS=windowsCGO_ENABLED=1PATH=D:\\golang\\mingw64\\bin;%GOROOT%\\bin;%PATH%LITEIDE_GDB=gdb64LITEIDE_MAKE=mingw32-makeLITEIDE_TERM=%COMSPEC%LITEIDE_TERMARGS=LITEIDE_EXEC=%COMSPEC%LITEIDE_EXECOPT=/C 五、GOPATH 设置查看 → 管理 GOPATH…，我们这里就使用安装 Go 时设置的那个 GOPATH 六、新建项目Ctrl + N 打开新项目或文件对话框，GOPATH 选择上一步的那个，模板选择 Go1 Command Project，最后取个名字，比如 test：点击 OK，test 项目已建立：完整测试代码：// test project main.gopackage mainimport ( \"fmt\")func main() &#123; var i int = 20 i += 30 j := i + 10 fmt.Println(j)&#125; 七、设置编译选项并编译编译 → 编译配置，BUILDARGS 设置为 -gcflags “-N -l”，以去掉编译优化，方便调试： 八、项目调试按 F5 启动调试，程序在 main 函数处停止：按 F10 （逐过程）进行单步调试，注意变量 i、j 值的变化：按 F11 （逐语句） 参考文章golang环境搭建Windows 平台下 LiteIDE 的安装和使用","categories":[],"tags":[{"name":"GoLang","slug":"GoLang","permalink":"http://localhost:4000/tags/GoLang/"},{"name":"环境配置","slug":"环境配置","permalink":"http://localhost:4000/tags/环境配置/"}]},{"title":"设计模式","slug":"设计模式","date":"2018-06-19T05:21:04.000Z","updated":"2018-06-19T09:51:15.977Z","comments":true,"path":"2018/06/19/设计模式/","link":"","permalink":"http://localhost:4000/2018/06/19/设计模式/","excerpt":"","text":"一 设计模式分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。 二 设计模式的六大原则总原则：开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 1. 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该吧类拆分。 2. 里氏替换原则（Liskov Subsitution Principle） 里氏替换原则（Liskov Subsitution Principle LSP）面向对象设计的基本原则之一。里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时。基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏替换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3. 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到的具体类时，不与具体类交互，而与具体类的上层接口交互。 4. 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5. 迪米特法则（最少知道原则）（Demeter Principle） 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6. 合成复用原则（Composite Reuse Principle） 原则是尽量首先使用合成/聚合的方式，而不是使用继承。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://localhost:4000/tags/设计模式/"}]},{"title":"Spring boot 系列（四）filter shiro","slug":"Spring boot 系列（四）","date":"2018-06-07T02:48:15.000Z","updated":"2018-06-19T02:48:33.679Z","comments":true,"path":"2018/06/07/Spring boot 系列（四）/","link":"","permalink":"http://localhost:4000/2018/06/07/Spring boot 系列（四）/","excerpt":"","text":"","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"filter","slug":"filter","permalink":"http://localhost:4000/tags/filter/"},{"name":"shiro","slug":"shiro","permalink":"http://localhost:4000/tags/shiro/"}]},{"title":"Spring boot 系列（三）tomcat部署","slug":"Spring boot 系列（三）","date":"2018-06-06T03:04:36.000Z","updated":"2018-06-19T02:48:06.402Z","comments":true,"path":"2018/06/06/Spring boot 系列（三）/","link":"","permalink":"http://localhost:4000/2018/06/06/Spring boot 系列（三）/","excerpt":"","text":"1. 修改打包方式 在pom.xml里设置 war 2. 移除嵌入式tomcat插件 在pom.xml里找到spring-boot-starter-web依赖节点，在其中添加如下代码 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 移除嵌入式tomcat插件 --&gt; &lt;!-- &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; --&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3. 添加servlet-api的依赖&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 4. 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法 /** * SprintBootApplication */@SpringBootApplicationpublic class BootApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; // 注意这里要指向原先用main方法执行的Application启动类 return application.sources(BootApplication.class); &#125; /** * @param args */ public static void main(String[] args) &#123; SpringApplication.run(BootApplication.class, args); &#125;&#125; 5. maven 打包 mvn clean compile package","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"tomcat部署","slug":"tomcat部署","permalink":"http://localhost:4000/tags/tomcat部署/"}]},{"title":"Spring boot 系列（二）文件上传","slug":"Spring boot 系列（二）","date":"2018-06-06T02:24:45.000Z","updated":"2018-06-19T02:48:19.909Z","comments":true,"path":"2018/06/06/Spring boot 系列（二）/","link":"","permalink":"http://localhost:4000/2018/06/06/Spring boot 系列（二）/","excerpt":"","text":"实现功能说明文件上传，并支持展示上传文件 问题描述 报错信息 org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.2737591724424319502.8080/work/Tomcat/localhost/ROOT] is not valid 报错代码 : file.transferTo 方法 public String storeScale(MultipartFile file, String basePath, int maxWidth) throws Exception &#123; validateFile(file); String root = getRoot(); String path = FileNameUtils.genPathAndFileName(getExt(file.getOriginalFilename())); File temp = new File(root + appContext.getTempDir() + path); checkDirAndCreate(temp); try &#123; file.transferTo(temp); // 根据临时文件生成略缩图 String dest = root + basePath + path; ImageUtils.scaleImageByWidth(temp.getAbsolutePath(), dest, maxWidth); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; temp.delete(); &#125; return basePath + path;&#125; 问题分析 上面源码文件使用路径 ，相对路径, 预期路径应该是 root + appContext.getTempDir() + path ，但是报错却是一个系统临时文件路径 （Tomcat的） 其次，由于transferTo方法报错，应该是写文件的时候报错，跟踪源码如下 /** * Spring MultipartHttpServletRequest adapter, wrapping a Servlet 3.0 HttpServletRequest * and its Part objects. Parameters get exposed through the native request's getParameter * methods - without any custom processing on our side. * * @author Juergen Hoeller * @author Rossen Stoyanchev * @since 3.1 */public class StandardMultipartHttpServletRequest extends AbstractMultipartHttpServletRequest &#123; ... @Override public void transferTo(File dest) throws IOException, IllegalStateException &#123; this.part.write(dest.getPath()); // 写文件方法入口 if (dest.isAbsolute() &amp;&amp; !dest.exists()) &#123; // Servlet 3.0 Part.write is not guaranteed to support absolute file paths: // may translate the given path to a relative location within a temp dir // (e.g. on Jetty whereas Tomcat and Undertow detect absolute paths). // At least we offloaded the file from memory storage; it'll get deleted // from the temp dir eventually in any case. And for our user's purposes, // we can manually copy it to the requested location as a fallback. FileCopyUtils.copy(this.part.getInputStream(), new FileOutputStream(dest)); &#125; &#125; ...&#125;/** * Adaptor to allow &#123;@link FileItem&#125; objects generated by the package renamed * commons-upload to be used by the Servlet 3.0 upload API that expects * &#123;@link Part&#125;s. */public class ApplicationPart implements Part &#123; ... @Override public void write(String fileName) throws IOException &#123; File file = new File(fileName); if (!file.isAbsolute()) &#123; // 此处判断如果不是绝对路径，则会添加location file = new File(location, fileName); &#125; try &#123; fileItem.write(file); &#125; catch (Exception e) &#123; throw new IOException(e); &#125; &#125; ...&#125; 源码一目了然，使用Servlet3.0的支持的上传文件功能时，如果我们没有使用绝对路径的话，transferTo方法会在相对路径前添加一个location路径，即：file = new File(location, fileName);。当然，这也影响了SpringMVC的Multipartfile的使用 解决方法 使用绝对路径 指定临时文件location路径 /** * 文件上传临时路径 */ @Bean MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); String location = appContext.getRoot(); File file = new File(location); if (!file.exists()) &#123; file.mkdirs();&#125; factory.setLocation(location); return factory.createMultipartConfig(); &#125; /** * appContext.getRoot() 文件存放路径 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/store/**\").addResourceLocations(\"file:\" + appContext.getRoot() + \"/store/\"); super.addResourceHandlers(registry); &#125; 文章参考：https://blog.csdn.net/daniel7443/article/details/51620308","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"文件上传","slug":"文件上传","permalink":"http://localhost:4000/tags/文件上传/"}]},{"title":"org.apache.maven.archiver.MavenArchiver.getManifest错误","slug":"eclipse-maven","date":"2018-05-30T03:36:53.000Z","updated":"2018-05-30T03:45:14.979Z","comments":true,"path":"2018/05/30/eclipse-maven/","link":"","permalink":"http://localhost:4000/2018/05/30/eclipse-maven/","excerpt":"","text":"在给eclipse换了高版本的maven插件后，引入jar包报如下的错误：org.apache.maven.archiver.MavenArchiver.getManifest(org.apache.maven.project 解决方法是：help–&gt;install new software, 然后add，添加如下链接， http://repo1.maven.org/maven2/.m2e/connectors/m2eclipse-mavenarchiver/0.17.2/N/LATEST/ 一直下一步就可以，后面提示重启eclipse，然后重启eclipse后，右击项目，点击maven–&gt;update project， 错误就没了","categories":[],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://localhost:4000/tags/eclipse/"},{"name":"maven","slug":"maven","permalink":"http://localhost:4000/tags/maven/"}]},{"title":"Spring boot 系列（一）相关文档","slug":"Spring boot 系列（一）","date":"2018-05-30T03:17:11.000Z","updated":"2018-06-19T02:48:15.681Z","comments":true,"path":"2018/05/30/Spring boot 系列（一）/","link":"","permalink":"http://localhost:4000/2018/05/30/Spring boot 系列（一）/","excerpt":"","text":"Spring官方网站本身使用Spring框架开发，随着功能以及业务逻辑的日益复杂，应用伴随着大量的XML配置文件以及复杂的Bean依赖关系。随着Spring 3.0的发布，Spring IO团队逐渐开始摆脱XML配置文件，并且在开发过程中大量使用“约定优先配置”（convention over configuration）的思想来摆脱Spring框架中各类繁复纷杂的配置（即时是Java Config）。 Spring Boot正是在这样的一个背景下被抽象出来的开发框架，它本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box），大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 相关文档 Spring 中文文档 http://spring.cndocs.ml/ Spring boot 中文文档 http://blog.geekidentity.com/spring/spring_boot_translation/ spring boot 2.0 官方文档 https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/ Spring Boot教程 https://www.yiibai.com/spring-boot/ spring boot 实践学习案例 https://github.com/JeffLi1993/springboot-learning-example","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"}]},{"title":"微信公共账号（一）","slug":"微信公共账号（一）","date":"2018-05-26T01:50:04.000Z","updated":"2018-06-04T00:51:37.373Z","comments":true,"path":"2018/05/26/微信公共账号（一）/","link":"","permalink":"http://localhost:4000/2018/05/26/微信公共账号（一）/","excerpt":"","text":"订目标，做计划，大量的行动。——陈安之言之易，行之难。——吕不韦 相关文档、工具 微信公众平台技术文档官网 微信Java开发工具包 weixin-java-tools weixin-java-tools Demo 微信服务号本地调试,参考外网访问你机器上的Demo 问题AES加密时的 java.security.InvalidKeyException: Illegal key size 异常程序代码// 设置加密模式为AES的CBC模式Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");SecretKeySpec keySpec = new SecretKeySpec(aesKey, \"AES\");IvParameterSpec iv = new IvParameterSpec(aesKey, 0, 16);cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);// 加密byte[] encrypted = cipher.doFinal(unencrypted);... 当执行到cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv); 时, 如果密钥大于128, 会抛出java.security.InvalidKeyException: Illegal key size 异常.因为密钥长度是受限制的, java运行时环境读到的是受限的policy文件. 文件位于${java_home}/jre/lib/security, 这种限制是因为美国对软件出口的控制. 处理办法: 在官方网站下载JCE无限制权限策略文件 JDK6的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.htmlJDK7的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.htmlJDK8的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt如果安装了JRE，将两个jar文件放到%JRE_HOME%\\lib\\security目录下覆盖原来的文件如果安装了JDK，还要将两个jar文件也放到%JDK_HOME%\\jre\\lib\\security目录下覆盖原来文件 更多问题参考weixin-java-tools微信Java SDK开发文档","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://localhost:4000/tags/spring-boot/"},{"name":"maven","slug":"maven","permalink":"http://localhost:4000/tags/maven/"},{"name":"微信公共号","slug":"微信公共号","permalink":"http://localhost:4000/tags/微信公共号/"},{"name":"java","slug":"java","permalink":"http://localhost:4000/tags/java/"}]},{"title":"外网访问你机器上的Demo","slug":"外网访问你机器上的Demo","date":"2018-05-25T03:10:11.000Z","updated":"2018-05-25T03:22:00.630Z","comments":true,"path":"2018/05/25/外网访问你机器上的Demo/","link":"","permalink":"http://localhost:4000/2018/05/25/外网访问你机器上的Demo/","excerpt":"","text":"想在外网访问你机器上的demo? 几个内网端口映射服务网站 http://wendal.cn Nutz社区提供的ngrok服务，详细访问 https://nutz.cn/yvr/t/33b68q9106imspallbj4c6aa0p http://www.mofasuidao.cn/ 拥有魔法隧道，让你穿越世界，引领「内网穿透」潮流，为世界带来美好的改变 http://natapp.cn/ http://ngrok.io == http://ngrok.com http://ngrok.2bdata.com/ http://www.ngrok.cc/ http://www.nat123.com/ ngrok使用 下载ngrok,点我 打开shell或cmd，进入ngrok目录，运行 ngrok -config ngrok.cfg -subdomain my-domain 8080 如果运行失败，请更换my-domain为其它字符串，直至连接成功； 外网访问地址：http://my-domain.tunnel.qydev.com/ （注意my-domain要跟上面的一致）；","categories":[],"tags":[{"name":"代理","slug":"代理","permalink":"http://localhost:4000/tags/代理/"}]},{"title":"计划","slug":"计划","date":"2018-05-25T01:51:48.000Z","updated":"2018-05-25T09:05:34.208Z","comments":true,"path":"2018/05/25/计划/","link":"","permalink":"http://localhost:4000/2018/05/25/计划/","excerpt":"","text":"西汉·戴圣《礼记·中庸》：“凡事豫则立，不豫则废。” 计划 个人博客 微信服务号石门蓝小球 PC站Mvp51 个人博客 Hexo博客搭建教程 Hexo手机端样式调整 Hexo支持评论功能，目前计划评论功能不使用第三方插件 石门蓝小球 微信服务号后台，支持用户上传收集信息（文字、图片、语音） 支持查询石家庄附件球场，通过关键词+Hexo静态页面 Mvp51 设计图效果 附近球场、球友、球队功能支持","categories":[],"tags":[{"name":"计划","slug":"计划","permalink":"http://localhost:4000/tags/计划/"}]},{"title":"Hexo工作原理","slug":"Hexo如何工作","date":"2018-05-24T01:18:22.000Z","updated":"2018-05-24T01:27:54.140Z","comments":true,"path":"2018/05/24/Hexo如何工作/","link":"","permalink":"http://localhost:4000/2018/05/24/Hexo如何工作/","excerpt":"","text":"你可能用过hexo(或者jekyll)来搭建自己的博客网站。通常我们在安装、配置完成hexo之后，借助hexo，一般通过以下步骤，就可以完成一篇博客的编写及发布，真是方便极了： |$ hexo init // 创建一个新的hexo项目$ hexo new mynewblog // 新建一篇标题为mynewblog的文章$ hexo server // 为hexo在本地起一个http server, 然后通过浏览器访问博客$ hexo generate // 生成将要发布的博客网站包含html在内的静态资源$ hexo deploy // 将generate的结果发布到_config.yml中指定的仓库 | 可是，从hexo init到hexo deploy中间发生了什么呢？为了搞清楚这一过程、理解hexo的工作原理，本文将试着回答以下问题: 命令行中的hexo是什么 hexo是怎么将我们写好的markdown转换成html的 hexo插件是如何工作的 本地的hexo项目和git page有什么关系 本文不是: hexo的安装、使用教程 git page的使用教程 命令行中的hexo是什么?hexo项目在github上已经有超过17k的star了，但是你知道吗，日常我们在命令行”操作”hexo时所输入的hexo(例如hexo init)并不是这个17k个star的项目! 是的，我们在命令行中所输入的”hexo”实际是hexo-cli项目，该项目在github上的star还不足50个。 hexo可以粗略分为三个子项目，分别是: hexo-cli hexo (下文中用hexo core来指代) hexo plugins 其中hexo plugins不是指某一个单独的项目，而是泛指所有的hexo plugin项目。 请看下图:让我们结合这张图来大致看看这三个项目的作用(下面的链接均是指向Github中相关的源码): hexo-cli: hexo命令行项目，作用是: 启动hexo命令(进程)，及其参数解析机制。每次我们输入’hexo xxx’命令后，都会通过node调用hexo-cli中的entry函数(比如，可以把’hexo init’视为’node hexo-cli/entry.js init’) 实现hexo命令的三个初始参数(功能): init / version / help 加载hexo核心模块，并初始化 hexo core: hexo核心，他的主要作用如下: 实现了hexo功能扩展对象 实现了hexo核心功能, 如new, publish, generate等（其实是一些hexo插件，下文中会详细分析） hexo plugins: 指一些能够扩展hexo的插件。插件可以按功能分成两类: 扩展hexo命令的参数，如hexo-server(安装这个插件以后才能使用hexo server命令) 扩展hexo解析文件的”能力”，如增加jade模版解析功能的hexo-render-jade插件 从markdown到html的旅程简单来说，hexo中，从markdown到html的generate过程中做了两件事： 模板渲染 模板渲染 是的，就是这样，就是两次模板渲染。只不过两次渲染的输入、渲染模板的引擎、输出不一样。此处应该有一个表格：还得有一张图: 对上面表格和图的说明: hexo core在generate的过程中会产生一个对象，我们在这里把这个对象称为article。第一次渲染的主要目的就是给这个对象添加title,content等属性。其中: article.title, article.date, article.tags, article.categories等属性来自yml front的部分 article.content是markdown文章解析后的html片段 hexo项目目录下包含三个子目录， source目录，写博客的主要工作目录。这个目录下存放的是我们的markdown文章以及js, images, css themes目录，主题目录，定义了即将生成的html的layout, 和html中需要加载的css, js, images public目录, hexo generate的最终输出目录。里面包含了整个博客网站的html, css, js, images 第二次渲染，需要引入对应模板文件格式的插件，如.ejs文件就需要使用hexo-render-ejs插件，.jade文件需要使用hexo-render-jade插件，而.sass文件则需要hexo-render-sass插件来转换成css文件。hexo的这一设计有点类似webpack中的loader。 hexo插件是如何工作的hexo和webpack还有一点类似的地方就是插件驱动理念。即hexo(和webpack)是先实现一套(插件)扩展系统，然后再往扩展系统中添加插件来实现自身的功能。即我们日常使用的hexo init, hexo new，hexo generate等等功能都是通过一个个插件(其实就是一个个function)实现的。 具体来讲就是: hexo.extend这个对象的每个属性都是一个用来绑定(特定)插件的对象。（所谓”绑定”，其实就是对象的register方法） hexo初始化过程中先加载内部插件，再加载外部插件 而这些插件的功能分为两大类: 命令行插件和generate过程相关功能，例如： 命令行插件, hexo new, 是在hexo.extend.console对象上绑定的一个插件 generate过程相关的插件，如上文提到的往article对象添加title,content等属性的功能，是通过往hexo.extend.processer对象上绑定post插件来实现的 所以，当我们想自己动手写插件时，就是像hexo官网给出的这样,调用某个对象的register方法，如hexo.extend.console.register。 hexo和git page 如上图，(用户通过浏览器访问到的)git page上的博客网站其实是hexo generate之后生成的public目录下的内容。 所以，一个hexo博客项目应该有两个仓库: (基于hexo init结果的)博客编写仓库。可以把这个项目看成一个代码库，用来”开发”博客网站(包含写博客，生成博客等任务) 存放(hexo generate结果的)public目录仓库。这个项目是”只读”的，我们不会直接修改这个仓库的内容，我们也不会对这个仓库直接进行git pull、git commit、git push等常规操作。这个仓库的内容就是public目下的内容，即是通过hexo generate产生、hexo deploy提交的。 总结hexo简洁、强大的功能来自于自身优雅的系统设计: hexo进程启动、hexo核心对象封装、插件系统分别独立 自身采用插件驱动，生来就具备高可扩展性 文章转载于hexo是怎么工作的","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://localhost:4000/tags/Hexo/"}]},{"title":"Windows Git安装环境配置","slug":"Windows Git安装环境配置","date":"2018-05-23T08:10:42.000Z","updated":"2018-05-25T02:01:21.329Z","comments":true,"path":"2018/05/23/Windows Git安装环境配置/","link":"","permalink":"http://localhost:4000/2018/05/23/Windows Git安装环境配置/","excerpt":"","text":"世上无难事只怕有心人！ 下载安装 从Git官网下载Windows安装包，官网地址 点我 参考https://blog.csdn.net/dietime1943/article/details/71751007安装 环境变量配置环境变量Path 或者 直接使用 git-bash.exeD:\\Program Files\\Git\\cmd Git常用命令简单命令# 版本查看$ git --versiongit version 2.17.0.windows.1 新建代码库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置# 显示当前Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2]# 停止追踪指定文件，但该文件会保留在工作区$ git rm -cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，代替上一次提交# 如果代码没有任何变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit, 并包括指定文件的新变化$ git commit --amend [file1] [file2] 分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]$ 删除远程分支$ git push origin -delete [branch-name]$ git branch -dr [remote/branch] Git原理Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 相关链接阮一峰常用 Git 命令清单","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"http://localhost:4000/tags/windows/"},{"name":"git","slug":"git","permalink":"http://localhost:4000/tags/git/"}]},{"title":"Hexo搭建博客","slug":"Hexo搭建博客","date":"2018-05-23T01:37:40.000Z","updated":"2018-05-24T01:21:52.084Z","comments":true,"path":"2018/05/23/Hexo搭建博客/","link":"","permalink":"http://localhost:4000/2018/05/23/Hexo搭建博客/","excerpt":"","text":"零基础搭建个人博客（Hexo + Git）","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://localhost:4000/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-22T07:29:40.327Z","updated":"2018-05-24T01:57:38.791Z","comments":true,"path":"2018/05/22/hello-world/","link":"","permalink":"http://localhost:4000/2018/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://localhost:4000/tags/Hexo/"}]}]}